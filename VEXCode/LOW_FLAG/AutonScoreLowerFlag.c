#pragma config(Sensor, dgtl1,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           flipper,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           left1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           left2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           left3,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           right1,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           right2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           right3,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           flywheelTop,   tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           flywheelBottom, tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          liftMotors,    tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Update log
7/26/18 - using pid to make sure both sides of the drive are moving at same rate
7/26/18 - using pid to make sure we dont overshoot the goal distance while making sure both sides of drive are moving at same rate.

*/

#define abs(X) ((X<0)?-1*X:X)

void driveStraightDistance(int inches, int masterPower, int wheelRadius, float gearRatio);
void powerLeftDrive(int power);
void powerRightDrive(int power);
void resetDriveEncoders();

//Using Proportional control, we will drive forward in a straight line. Proportionality constant needs to be tested and fine tuned
task main()	{
driveStraightDistance(42, 70, 2, 0.5);
}

void driveStraightDistance(int inches, int masterPower, int wheelRadius, float gearRatio)	{
	int tickGoal = ((inches/(2*3.141528*wheelRadius))*627.2)* gearRatio;
  int totalTicks = 0;//This will count up the total encoder ticks despite the fact that the encoders are constantly reset.
  int slavePower = masterPower; //left side is master side
  int sideError;
  int error;
  float driveKp = 0.2; //follow testing procedure to fine tune
  float sideKp = 0.2; //follow testing procedure to fine tune. fine tune this piece first.
 	bool timerBool = true; //timer based on error to stop oscillation

  resetDriveEncoders(); //reset encoders
	powerLeftDrive(masterPower);//start drive motors
  powerRightDrive(slavePower);
  //Monitor 'totalTicks', instead of the values of the encoders which are constantly reset.
  wait1Msec(10);
  while(timerBool)	{

  	totalTicks += SensorValue[leftEncoder];
  	error = tickGoal - totalTicks;
  	masterPower = error * driveKp;

    //Proportional algorithm to keep the robot going straight.
    powerLeftDrive(masterPower);
    powerRightDrive(masterPower);
    sideError = SensorValue[leftEncoder] - SensorValue[rightEncoder];
    slavePower = sideError * sideKp;
		resetDriveEncoders();
    wait1Msec(40);

    //Add this iteration's encoder values to totalTicks.
    totalTicks+= SensorValue[leftEncoder];

    if(error < 30)	{ //edit the condition later based on experimental results
    	timerBool = false;
    }
  }
  powerLeftDrive(0); // Stop the loop once the encoders have counted up the correct number of encoder ticks.
  powerRightDrive(0);
}

void powerLeftDrive(int power) {
   motor[left1] = power;
   motor[left2] = power * -1;
   motor[left3] = power;
}

void powerRightDrive(int power) {
   motor[left1] = power * -1;
   motor[left2] = power ;
   motor[left3] = power * -1;
}
void resetDriveEncoders()	{
	SensorValue[leftEncoder] = 0;
  SensorValue[rightEncoder] = 0;
}
