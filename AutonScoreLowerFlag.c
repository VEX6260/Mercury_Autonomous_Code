#pragma config(Sensor, dgtl1,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port2,           left1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           left2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           left3,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           right1,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           right2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           right3,        tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define abs(X) ((X<0)?-1*X:X)

void driveStraightDistance(int inches, int masterPower, int wheelRadius, float gearRatio);
void powerLeftDrive(int power);
void powerRightDrive(int power);
void resetDriveEncoders();

//Using Proportional control, we will drive forward in a straight line. Proportionality constant needs to be tested and fine tuned
task main()
{
driveStraightDistance(42, 70, 2, 0.5);
}

void driveStraightDistance(int inches, int masterPower, int wheelRadius, float gearRatio)	{
	int tickGoal = ((inches/(2*3.141528*wheelRadius))*627.2)* gearRatio;
  int totalTicks = 0;//This will count up the total encoder ticks despite the fact that the encoders are constantly reset.
  int slavePower = masterPower;
  int error;
  float kp = 0.2; //follow testing procedure to fine tune
  resetDriveEncoders();

  //Monitor 'totalTicks', instead of the values of the encoders which are constantly reset.
  while(abs(totalTicks) < tickGoal)
  {
    //Proportional algorithm to keep the robot going straight.
    powerLeftDrive(masterPower);
    powerRightDrive(slavePower);

    error = SensorValue[leftEncoder] - SensorValue[rightEncoder];

    slavePower += error * kp;

		resetDriveEncoders();

    wait1Msec(100);

    //Add this iteration's encoder values to totalTicks.
    totalTicks+= SensorValue[leftEncoder];
  }
  powerLeftDrive(0); // Stop the loop once the encoders have counted up the correct number of encoder ticks.
  powerRightDrive(0);
}

void powerLeftDrive(int power) {
   motor[left1] = power;
   motor[left2] = power * -1;
   motor[left3] = power;
}

void powerRightDrive(int power) {
   motor[left1] = power * -1;
   motor[left2] = power ;
   motor[left3] = power * -1;
}
void resetDriveEncoders()	{
	SensorValue[leftEncoder] = 0;
  SensorValue[rightEncoder] = 0;
}
